Given an array of intervals where intervals[i] = [starti, endi], merge all overlapping intervals, and return an array of the non-overlapping intervals that cover all the intervals in the input.
Input: intervals = [[1,3],[2,6],[8,10],[15,18]]
Output: [[1,6],[8,10],[15,18]]
Explanation: Since intervals [1,3] and [2,6] overlaps, merge them into [1,6].

class Solution {
    public int[][] merge(int[][] intervals) {
        //sort intervals based on start
        Arrays.sort(intervals, (a,b)->Integer.compare(a[0],b[0]));
        List<List<Integer>> res= new ArrayList<>();
        
        int start = intervals[0][0];
        int end = intervals[0][1];
        
        for(int r=1; r<intervals.length; r++){
            List<Integer> temp = new ArrayList<>();
            //if next start is bigger than previous end, not in same interval
            if(end < intervals[r][0]){
                temp.add(start);
                temp.add(end);
                res.add(new ArrayList<>(temp));
                start = intervals[r][0];
                end = intervals[r][1];
            }else if(end <= intervals[r][1]){
                //if next end is bigger than previous, in same interval
                end = intervals[r][1];
            }
                
        }
        
        List<Integer> temp = new ArrayList<>();
        temp.add(start);
        temp.add(end);
        res.add(temp);
    
        int[][] ress = new int[res.size()][2];
        //transform to array
        for(int i=0; i<res.size(); i++){
            List<Integer> newTemp = res.get(i);
            for(int j=0; j<2; j++){
                ress[i][j]= newTemp.get(j);
            }
        }
        
        return ress;
    }
}
