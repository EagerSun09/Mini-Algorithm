Given a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements.

Your task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums.

class Solution {
    public int findShortestSubArray(int[] nums) {
        //preparation
        HashMap<Integer, int[]> map = new HashMap<>();
        int maxFre = 0;
        int minLen = Integer.MAX_VALUE;
        
        //value[0] indicates the left most position of current num
        //value[1] denotes the right most position of current num
        //value[2] is the frequency of current num
        for(int i=0; i<nums.length; i++){
            if(map.containsKey(nums[i])){
                int[] value = map.get(nums[i]);
                value[1] = i;
                value[2] += 1;
                map.put(nums[i], value);
            }else{
                map.put(nums[i], new int[]{i,i,1});
            }
        }
        //GET THE RESULT PART
        for(int[] res:map.values()){
            if(res[2] > maxFre){
                maxFre = res[2];
                minLen = res[1]-res[0]+1;
            }else if(res[2] == maxFre){
                minLen = Math.min(minLen, res[1]-res[0]+1);
            }
        }
        
        return minLen;
    }
}
